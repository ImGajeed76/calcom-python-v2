# coding: utf-8

"""
    Cal.com API v2

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.booker_layouts20240614 import BookerLayouts20240614
from openapi_client.models.create_event_type_input20240614_locations_inner import CreateEventTypeInput20240614LocationsInner
from openapi_client.models.destination_calendar20240614 import DestinationCalendar20240614
from openapi_client.models.event_type_color20240614 import EventTypeColor20240614
from openapi_client.models.event_type_output20240614_booking_fields_inner import EventTypeOutput20240614BookingFieldsInner
from openapi_client.models.event_type_output20240614_booking_window_inner import EventTypeOutput20240614BookingWindowInner
from openapi_client.models.recurrence20240614 import Recurrence20240614
from openapi_client.models.seats20240614 import Seats20240614
from openapi_client.models.team_event_type_response_host import TeamEventTypeResponseHost
from typing import Optional, Set
from typing_extensions import Self

class TeamEventTypeOutput20240614(BaseModel):
    """
    TeamEventTypeOutput20240614
    """ # noqa: E501
    id: Union[StrictFloat, StrictInt]
    length_in_minutes: Union[Annotated[float, Field(strict=True, ge=1)], Annotated[int, Field(strict=True, ge=1)]] = Field(alias="lengthInMinutes")
    title: StrictStr
    slug: StrictStr
    description: StrictStr
    locations: List[CreateEventTypeInput20240614LocationsInner]
    booking_fields: List[EventTypeOutput20240614BookingFieldsInner] = Field(alias="bookingFields")
    disable_guests: StrictBool = Field(alias="disableGuests")
    slot_interval: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="slotInterval")
    minimum_booking_notice: Optional[Union[Annotated[float, Field(strict=True, ge=0)], Annotated[int, Field(strict=True, ge=0)]]] = Field(default=None, alias="minimumBookingNotice")
    before_event_buffer: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="beforeEventBuffer")
    after_event_buffer: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="afterEventBuffer")
    recurrence: Optional[Recurrence20240614]
    metadata: Dict[str, Any]
    price: Union[StrictFloat, StrictInt]
    currency: StrictStr
    lock_time_zone_toggle_on_booking_page: StrictBool = Field(alias="lockTimeZoneToggleOnBookingPage")
    seats_per_time_slot: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="seatsPerTimeSlot")
    forward_params_success_redirect: Optional[StrictBool] = Field(alias="forwardParamsSuccessRedirect")
    success_redirect_url: Optional[StrictStr] = Field(alias="successRedirectUrl")
    is_instant_event: StrictBool = Field(alias="isInstantEvent")
    seats_show_availability_count: Optional[StrictBool] = Field(default=None, alias="seatsShowAvailabilityCount")
    schedule_id: Optional[Union[StrictFloat, StrictInt]] = Field(alias="scheduleId")
    booking_limits_count: Optional[Dict[str, Any]] = Field(default=None, alias="bookingLimitsCount")
    only_show_first_available_slot: Optional[StrictBool] = Field(default=None, alias="onlyShowFirstAvailableSlot")
    booking_limits_duration: Optional[Dict[str, Any]] = Field(default=None, alias="bookingLimitsDuration")
    booking_window: Optional[List[EventTypeOutput20240614BookingWindowInner]] = Field(default=None, description="Limit how far in the future this event can be booked", alias="bookingWindow")
    booker_layouts: Optional[BookerLayouts20240614] = Field(default=None, alias="bookerLayouts")
    confirmation_policy: Optional[Dict[str, Any]] = Field(default=None, alias="confirmationPolicy")
    requires_booker_email_verification: Optional[StrictBool] = Field(default=None, alias="requiresBookerEmailVerification")
    hide_calendar_notes: Optional[StrictBool] = Field(default=None, alias="hideCalendarNotes")
    color: Optional[EventTypeColor20240614] = None
    seats: Optional[Seats20240614] = None
    offset_start: Optional[Union[Annotated[float, Field(strict=True, ge=1)], Annotated[int, Field(strict=True, ge=1)]]] = Field(default=None, alias="offsetStart")
    custom_name: Optional[StrictStr] = Field(default=None, alias="customName")
    destination_calendar: Optional[DestinationCalendar20240614] = Field(default=None, alias="destinationCalendar")
    use_destination_calendar_email: Optional[StrictBool] = Field(default=None, alias="useDestinationCalendarEmail")
    hide_calendar_event_details: Optional[StrictBool] = Field(default=None, alias="hideCalendarEventDetails")
    team_id: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="teamId")
    owner_id: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="ownerId")
    parent_event_type_id: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="For managed event types, parent event type is the event type that this event type is based on", alias="parentEventTypeId")
    hosts: List[TeamEventTypeResponseHost]
    assign_all_team_members: Optional[StrictBool] = Field(default=None, alias="assignAllTeamMembers")
    scheduling_type: Optional[StrictStr] = Field(alias="schedulingType")
    __properties: ClassVar[List[str]] = ["id", "lengthInMinutes", "title", "slug", "description", "locations", "bookingFields", "disableGuests", "slotInterval", "minimumBookingNotice", "beforeEventBuffer", "afterEventBuffer", "recurrence", "metadata", "price", "currency", "lockTimeZoneToggleOnBookingPage", "seatsPerTimeSlot", "forwardParamsSuccessRedirect", "successRedirectUrl", "isInstantEvent", "seatsShowAvailabilityCount", "scheduleId", "bookingLimitsCount", "onlyShowFirstAvailableSlot", "bookingLimitsDuration", "bookingWindow", "bookerLayouts", "confirmationPolicy", "requiresBookerEmailVerification", "hideCalendarNotes", "color", "seats", "offsetStart", "customName", "destinationCalendar", "useDestinationCalendarEmail", "hideCalendarEventDetails", "teamId", "ownerId", "parentEventTypeId", "hosts", "assignAllTeamMembers", "schedulingType"]

    @field_validator('scheduling_type')
    def scheduling_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ROUND_ROBIN', 'COLLECTIVE', 'MANAGED']):
            raise ValueError("must be one of enum values ('ROUND_ROBIN', 'COLLECTIVE', 'MANAGED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TeamEventTypeOutput20240614 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in locations (list)
        _items = []
        if self.locations:
            for _item_locations in self.locations:
                if _item_locations:
                    _items.append(_item_locations.to_dict())
            _dict['locations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in booking_fields (list)
        _items = []
        if self.booking_fields:
            for _item_booking_fields in self.booking_fields:
                if _item_booking_fields:
                    _items.append(_item_booking_fields.to_dict())
            _dict['bookingFields'] = _items
        # override the default output from pydantic by calling `to_dict()` of recurrence
        if self.recurrence:
            _dict['recurrence'] = self.recurrence.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in booking_window (list)
        _items = []
        if self.booking_window:
            for _item_booking_window in self.booking_window:
                if _item_booking_window:
                    _items.append(_item_booking_window.to_dict())
            _dict['bookingWindow'] = _items
        # override the default output from pydantic by calling `to_dict()` of booker_layouts
        if self.booker_layouts:
            _dict['bookerLayouts'] = self.booker_layouts.to_dict()
        # override the default output from pydantic by calling `to_dict()` of color
        if self.color:
            _dict['color'] = self.color.to_dict()
        # override the default output from pydantic by calling `to_dict()` of seats
        if self.seats:
            _dict['seats'] = self.seats.to_dict()
        # override the default output from pydantic by calling `to_dict()` of destination_calendar
        if self.destination_calendar:
            _dict['destinationCalendar'] = self.destination_calendar.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in hosts (list)
        _items = []
        if self.hosts:
            for _item_hosts in self.hosts:
                if _item_hosts:
                    _items.append(_item_hosts.to_dict())
            _dict['hosts'] = _items
        # set to None if slot_interval (nullable) is None
        # and model_fields_set contains the field
        if self.slot_interval is None and "slot_interval" in self.model_fields_set:
            _dict['slotInterval'] = None

        # set to None if recurrence (nullable) is None
        # and model_fields_set contains the field
        if self.recurrence is None and "recurrence" in self.model_fields_set:
            _dict['recurrence'] = None

        # set to None if seats_per_time_slot (nullable) is None
        # and model_fields_set contains the field
        if self.seats_per_time_slot is None and "seats_per_time_slot" in self.model_fields_set:
            _dict['seatsPerTimeSlot'] = None

        # set to None if forward_params_success_redirect (nullable) is None
        # and model_fields_set contains the field
        if self.forward_params_success_redirect is None and "forward_params_success_redirect" in self.model_fields_set:
            _dict['forwardParamsSuccessRedirect'] = None

        # set to None if success_redirect_url (nullable) is None
        # and model_fields_set contains the field
        if self.success_redirect_url is None and "success_redirect_url" in self.model_fields_set:
            _dict['successRedirectUrl'] = None

        # set to None if seats_show_availability_count (nullable) is None
        # and model_fields_set contains the field
        if self.seats_show_availability_count is None and "seats_show_availability_count" in self.model_fields_set:
            _dict['seatsShowAvailabilityCount'] = None

        # set to None if schedule_id (nullable) is None
        # and model_fields_set contains the field
        if self.schedule_id is None and "schedule_id" in self.model_fields_set:
            _dict['scheduleId'] = None

        # set to None if team_id (nullable) is None
        # and model_fields_set contains the field
        if self.team_id is None and "team_id" in self.model_fields_set:
            _dict['teamId'] = None

        # set to None if owner_id (nullable) is None
        # and model_fields_set contains the field
        if self.owner_id is None and "owner_id" in self.model_fields_set:
            _dict['ownerId'] = None

        # set to None if parent_event_type_id (nullable) is None
        # and model_fields_set contains the field
        if self.parent_event_type_id is None and "parent_event_type_id" in self.model_fields_set:
            _dict['parentEventTypeId'] = None

        # set to None if scheduling_type (nullable) is None
        # and model_fields_set contains the field
        if self.scheduling_type is None and "scheduling_type" in self.model_fields_set:
            _dict['schedulingType'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TeamEventTypeOutput20240614 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "lengthInMinutes": obj.get("lengthInMinutes"),
            "title": obj.get("title"),
            "slug": obj.get("slug"),
            "description": obj.get("description"),
            "locations": [CreateEventTypeInput20240614LocationsInner.from_dict(_item) for _item in obj["locations"]] if obj.get("locations") is not None else None,
            "bookingFields": [EventTypeOutput20240614BookingFieldsInner.from_dict(_item) for _item in obj["bookingFields"]] if obj.get("bookingFields") is not None else None,
            "disableGuests": obj.get("disableGuests"),
            "slotInterval": obj.get("slotInterval"),
            "minimumBookingNotice": obj.get("minimumBookingNotice"),
            "beforeEventBuffer": obj.get("beforeEventBuffer"),
            "afterEventBuffer": obj.get("afterEventBuffer"),
            "recurrence": Recurrence20240614.from_dict(obj["recurrence"]) if obj.get("recurrence") is not None else None,
            "metadata": obj.get("metadata"),
            "price": obj.get("price"),
            "currency": obj.get("currency"),
            "lockTimeZoneToggleOnBookingPage": obj.get("lockTimeZoneToggleOnBookingPage"),
            "seatsPerTimeSlot": obj.get("seatsPerTimeSlot"),
            "forwardParamsSuccessRedirect": obj.get("forwardParamsSuccessRedirect"),
            "successRedirectUrl": obj.get("successRedirectUrl"),
            "isInstantEvent": obj.get("isInstantEvent"),
            "seatsShowAvailabilityCount": obj.get("seatsShowAvailabilityCount"),
            "scheduleId": obj.get("scheduleId"),
            "bookingLimitsCount": obj.get("bookingLimitsCount"),
            "onlyShowFirstAvailableSlot": obj.get("onlyShowFirstAvailableSlot"),
            "bookingLimitsDuration": obj.get("bookingLimitsDuration"),
            "bookingWindow": [EventTypeOutput20240614BookingWindowInner.from_dict(_item) for _item in obj["bookingWindow"]] if obj.get("bookingWindow") is not None else None,
            "bookerLayouts": BookerLayouts20240614.from_dict(obj["bookerLayouts"]) if obj.get("bookerLayouts") is not None else None,
            "confirmationPolicy": obj.get("confirmationPolicy"),
            "requiresBookerEmailVerification": obj.get("requiresBookerEmailVerification"),
            "hideCalendarNotes": obj.get("hideCalendarNotes"),
            "color": EventTypeColor20240614.from_dict(obj["color"]) if obj.get("color") is not None else None,
            "seats": Seats20240614.from_dict(obj["seats"]) if obj.get("seats") is not None else None,
            "offsetStart": obj.get("offsetStart"),
            "customName": obj.get("customName"),
            "destinationCalendar": DestinationCalendar20240614.from_dict(obj["destinationCalendar"]) if obj.get("destinationCalendar") is not None else None,
            "useDestinationCalendarEmail": obj.get("useDestinationCalendarEmail"),
            "hideCalendarEventDetails": obj.get("hideCalendarEventDetails"),
            "teamId": obj.get("teamId"),
            "ownerId": obj.get("ownerId"),
            "parentEventTypeId": obj.get("parentEventTypeId"),
            "hosts": [TeamEventTypeResponseHost.from_dict(_item) for _item in obj["hosts"]] if obj.get("hosts") is not None else None,
            "assignAllTeamMembers": obj.get("assignAllTeamMembers"),
            "schedulingType": obj.get("schedulingType")
        })
        return _obj


