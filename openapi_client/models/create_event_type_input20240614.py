# coding: utf-8

"""
    Cal.com API v2

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.booker_layouts20240614 import BookerLayouts20240614
from openapi_client.models.create_event_type_input20240614_booking_fields_inner import CreateEventTypeInput20240614BookingFieldsInner
from openapi_client.models.create_event_type_input20240614_booking_limits_count import CreateEventTypeInput20240614BookingLimitsCount
from openapi_client.models.create_event_type_input20240614_booking_limits_duration import CreateEventTypeInput20240614BookingLimitsDuration
from openapi_client.models.create_event_type_input20240614_booking_window import CreateEventTypeInput20240614BookingWindow
from openapi_client.models.create_event_type_input20240614_confirmation_policy import CreateEventTypeInput20240614ConfirmationPolicy
from openapi_client.models.create_event_type_input20240614_locations_inner import CreateEventTypeInput20240614LocationsInner
from openapi_client.models.create_event_type_input20240614_recurrence import CreateEventTypeInput20240614Recurrence
from openapi_client.models.create_event_type_input20240614_seats import CreateEventTypeInput20240614Seats
from openapi_client.models.destination_calendar20240614 import DestinationCalendar20240614
from openapi_client.models.event_type_color20240614 import EventTypeColor20240614
from typing import Optional, Set
from typing_extensions import Self

class CreateEventTypeInput20240614(BaseModel):
    """
    CreateEventTypeInput20240614
    """ # noqa: E501
    length_in_minutes: Union[StrictFloat, StrictInt] = Field(alias="lengthInMinutes")
    title: StrictStr
    slug: StrictStr
    description: Optional[StrictStr] = None
    locations: Optional[List[CreateEventTypeInput20240614LocationsInner]] = Field(default=None, description="Locations where the event will take place. If not provided, cal video link will be used as the location.")
    booking_fields: Optional[List[CreateEventTypeInput20240614BookingFieldsInner]] = Field(default=None, description="Custom fields that can be added to the booking form when the event is booked by someone. By default booking form has name and email field.", alias="bookingFields")
    disable_guests: Optional[StrictBool] = Field(default=None, description="If true, person booking this event't cant add guests via their emails.", alias="disableGuests")
    slot_interval: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Number representing length of each slot when event is booked. By default it equal length of the event type.       If event length is 60 minutes then we would have slots 9AM, 10AM, 11AM etc. but if it was changed to 30 minutes then       we would have slots 9AM, 9:30AM, 10AM, 10:30AM etc. as the available times to book the 60 minute event.", alias="slotInterval")
    minimum_booking_notice: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Minimum number of minutes before the event that a booking can be made.", alias="minimumBookingNotice")
    before_event_buffer: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Time spaces that can be pre-pended before an event to give more time before it.", alias="beforeEventBuffer")
    after_event_buffer: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Time spaces that can be appended after an event to give more time after it.", alias="afterEventBuffer")
    schedule_id: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="If you want that this event has different schedule than user's default one you can specify it here.", alias="scheduleId")
    booking_limits_count: Optional[CreateEventTypeInput20240614BookingLimitsCount] = Field(default=None, alias="bookingLimitsCount")
    only_show_first_available_slot: Optional[StrictBool] = Field(default=None, description="This will limit your availability for this event type to one slot per day, scheduled at the earliest available time.", alias="onlyShowFirstAvailableSlot")
    booking_limits_duration: Optional[CreateEventTypeInput20240614BookingLimitsDuration] = Field(default=None, alias="bookingLimitsDuration")
    booking_window: Optional[CreateEventTypeInput20240614BookingWindow] = Field(default=None, alias="bookingWindow")
    offset_start: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Offset timeslots shown to bookers by a specified number of minutes", alias="offsetStart")
    booker_layouts: Optional[BookerLayouts20240614] = Field(default=None, description="Should booker have week, month or column view. Specify default layout and enabled layouts user can pick.", alias="bookerLayouts")
    confirmation_policy: Optional[CreateEventTypeInput20240614ConfirmationPolicy] = Field(default=None, alias="confirmationPolicy")
    recurrence: Optional[CreateEventTypeInput20240614Recurrence] = None
    requires_booker_email_verification: Optional[StrictBool] = Field(default=None, alias="requiresBookerEmailVerification")
    hide_calendar_notes: Optional[StrictBool] = Field(default=None, alias="hideCalendarNotes")
    lock_time_zone_toggle_on_booking_page: Optional[StrictBool] = Field(default=None, alias="lockTimeZoneToggleOnBookingPage")
    color: Optional[EventTypeColor20240614] = None
    seats: Optional[CreateEventTypeInput20240614Seats] = None
    custom_name: Optional[StrictStr] = Field(default=None, description="Customizable event name with valid variables:        {Event type title}, {Organiser}, {Scheduler}, {Location}, {Organiser first name},        {Scheduler first name}, {Scheduler last name}, {Event duration}, {LOCATION},        {HOST/ATTENDEE}, {HOST}, {ATTENDEE}, {USER}", alias="customName")
    destination_calendar: Optional[DestinationCalendar20240614] = Field(default=None, alias="destinationCalendar")
    use_destination_calendar_email: Optional[StrictBool] = Field(default=None, alias="useDestinationCalendarEmail")
    hide_calendar_event_details: Optional[StrictBool] = Field(default=None, alias="hideCalendarEventDetails")
    __properties: ClassVar[List[str]] = ["lengthInMinutes", "title", "slug", "description", "locations", "bookingFields", "disableGuests", "slotInterval", "minimumBookingNotice", "beforeEventBuffer", "afterEventBuffer", "scheduleId", "bookingLimitsCount", "onlyShowFirstAvailableSlot", "bookingLimitsDuration", "bookingWindow", "offsetStart", "bookerLayouts", "confirmationPolicy", "recurrence", "requiresBookerEmailVerification", "hideCalendarNotes", "lockTimeZoneToggleOnBookingPage", "color", "seats", "customName", "destinationCalendar", "useDestinationCalendarEmail", "hideCalendarEventDetails"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateEventTypeInput20240614 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in locations (list)
        _items = []
        if self.locations:
            for _item_locations in self.locations:
                if _item_locations:
                    _items.append(_item_locations.to_dict())
            _dict['locations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in booking_fields (list)
        _items = []
        if self.booking_fields:
            for _item_booking_fields in self.booking_fields:
                if _item_booking_fields:
                    _items.append(_item_booking_fields.to_dict())
            _dict['bookingFields'] = _items
        # override the default output from pydantic by calling `to_dict()` of booking_limits_count
        if self.booking_limits_count:
            _dict['bookingLimitsCount'] = self.booking_limits_count.to_dict()
        # override the default output from pydantic by calling `to_dict()` of booking_limits_duration
        if self.booking_limits_duration:
            _dict['bookingLimitsDuration'] = self.booking_limits_duration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of booking_window
        if self.booking_window:
            _dict['bookingWindow'] = self.booking_window.to_dict()
        # override the default output from pydantic by calling `to_dict()` of booker_layouts
        if self.booker_layouts:
            _dict['bookerLayouts'] = self.booker_layouts.to_dict()
        # override the default output from pydantic by calling `to_dict()` of confirmation_policy
        if self.confirmation_policy:
            _dict['confirmationPolicy'] = self.confirmation_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of recurrence
        if self.recurrence:
            _dict['recurrence'] = self.recurrence.to_dict()
        # override the default output from pydantic by calling `to_dict()` of color
        if self.color:
            _dict['color'] = self.color.to_dict()
        # override the default output from pydantic by calling `to_dict()` of seats
        if self.seats:
            _dict['seats'] = self.seats.to_dict()
        # override the default output from pydantic by calling `to_dict()` of destination_calendar
        if self.destination_calendar:
            _dict['destinationCalendar'] = self.destination_calendar.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateEventTypeInput20240614 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "lengthInMinutes": obj.get("lengthInMinutes"),
            "title": obj.get("title"),
            "slug": obj.get("slug"),
            "description": obj.get("description"),
            "locations": [CreateEventTypeInput20240614LocationsInner.from_dict(_item) for _item in obj["locations"]] if obj.get("locations") is not None else None,
            "bookingFields": [CreateEventTypeInput20240614BookingFieldsInner.from_dict(_item) for _item in obj["bookingFields"]] if obj.get("bookingFields") is not None else None,
            "disableGuests": obj.get("disableGuests"),
            "slotInterval": obj.get("slotInterval"),
            "minimumBookingNotice": obj.get("minimumBookingNotice"),
            "beforeEventBuffer": obj.get("beforeEventBuffer"),
            "afterEventBuffer": obj.get("afterEventBuffer"),
            "scheduleId": obj.get("scheduleId"),
            "bookingLimitsCount": CreateEventTypeInput20240614BookingLimitsCount.from_dict(obj["bookingLimitsCount"]) if obj.get("bookingLimitsCount") is not None else None,
            "onlyShowFirstAvailableSlot": obj.get("onlyShowFirstAvailableSlot"),
            "bookingLimitsDuration": CreateEventTypeInput20240614BookingLimitsDuration.from_dict(obj["bookingLimitsDuration"]) if obj.get("bookingLimitsDuration") is not None else None,
            "bookingWindow": CreateEventTypeInput20240614BookingWindow.from_dict(obj["bookingWindow"]) if obj.get("bookingWindow") is not None else None,
            "offsetStart": obj.get("offsetStart"),
            "bookerLayouts": BookerLayouts20240614.from_dict(obj["bookerLayouts"]) if obj.get("bookerLayouts") is not None else None,
            "confirmationPolicy": CreateEventTypeInput20240614ConfirmationPolicy.from_dict(obj["confirmationPolicy"]) if obj.get("confirmationPolicy") is not None else None,
            "recurrence": CreateEventTypeInput20240614Recurrence.from_dict(obj["recurrence"]) if obj.get("recurrence") is not None else None,
            "requiresBookerEmailVerification": obj.get("requiresBookerEmailVerification"),
            "hideCalendarNotes": obj.get("hideCalendarNotes"),
            "lockTimeZoneToggleOnBookingPage": obj.get("lockTimeZoneToggleOnBookingPage"),
            "color": EventTypeColor20240614.from_dict(obj["color"]) if obj.get("color") is not None else None,
            "seats": CreateEventTypeInput20240614Seats.from_dict(obj["seats"]) if obj.get("seats") is not None else None,
            "customName": obj.get("customName"),
            "destinationCalendar": DestinationCalendar20240614.from_dict(obj["destinationCalendar"]) if obj.get("destinationCalendar") is not None else None,
            "useDestinationCalendarEmail": obj.get("useDestinationCalendarEmail"),
            "hideCalendarEventDetails": obj.get("hideCalendarEventDetails")
        })
        return _obj


